{"version":3,"names":["Definition","PatternVisitor","OriginalPatternVisitor","Referencer","OriginalReferencer","Scope","ScopeManager","require","getKeys","fallback","visitorKeysMap","getVisitorValues","nodeType","client","FLOW_FLIPPED_ALIAS_KEYS","VISITOR_KEYS","getTypesInfo","flowFlippedAliasKeys","Set","concat","Object","entries","o","keys","map","k","reduce","acc","key","value","has","propertyTypes","callProperties","type","values","indexers","properties","types","params","argument","elementType","qualification","rest","returnType","typeAnnotation","typeParameters","id","ArrayPattern","node","elements","forEach","visit","ObjectPattern","_client","WeakMap","constructor","options","scopeManager","_classPrivateFieldInitSpec","_classPrivateFieldSet","visitPattern","callback","_checkIdentifierOrVisit","left","processRightHandNodes","visitor","rightHandNodes","visitClass","_ref","_visitArray","decorators","typeParamScope","_nestTypeParamScope","_visitTypeAnnotation","implements","superTypeParameters","close","visitFunction","visitProperty","_node$value","InterfaceDeclaration","_createScopeVariable","extends","body","TypeAlias","right","ClassProperty","_visitClassProperty","ClassPrivateProperty","AccessorProperty","ClassAccessorProperty","PropertyDefinition","ClassPrivateMethod","MethodDefinition","DeclareModule","_visitDeclareX","DeclareFunction","DeclareVariable","DeclareClass","OptionalMemberExpression","MemberExpression","computed","__nestClassFieldInitializerScope","__nestScope","__currentScope","name","currentScope","variableScope","__define","parentScope","scope","j","length","bind","Array","isArray","visitorValues","_classPrivateFieldGet","i","visitorValue","propertyType","nodeProperty","loopPropertyNode","l","nodeList","module","exports","analyzeScope","ast","parserOptions","_parserOptions$ecmaFe","ignoreEval","optimistic","directive","nodejsScope","sourceType","ecmaFeatures","globalReturn","impliedStrict","ecmaVersion","childVisitorKeys","getVisitorKeys","referencer"],"sources":["../src/analyze-scope.cts"],"sourcesContent":["import type { Client } from \"./client.cts\";\n\nconst {\n  Definition,\n  PatternVisitor: OriginalPatternVisitor,\n  Referencer: OriginalReferencer,\n  Scope,\n  ScopeManager,\n} = (\n  process.env.BABEL_8_BREAKING\n    ? require(\"eslint-scope\")\n    : require(\"@nicolo-ribaudo/eslint-scope-5-internals\")\n) as import(\"./types.cts\").Scope;\nconst { getKeys: fallback } = require(\"eslint-visitor-keys\");\n\nlet visitorKeysMap: Record<string, string[]>;\nfunction getVisitorValues(nodeType: string, client: Client) {\n  if (visitorKeysMap) return visitorKeysMap[nodeType];\n\n  const { FLOW_FLIPPED_ALIAS_KEYS, VISITOR_KEYS } = client.getTypesInfo();\n\n  const flowFlippedAliasKeys = new Set(\n    FLOW_FLIPPED_ALIAS_KEYS.concat([\n      \"ArrayPattern\",\n      \"ClassDeclaration\",\n      \"ClassExpression\",\n      \"FunctionDeclaration\",\n      \"FunctionExpression\",\n      \"Identifier\",\n      \"ObjectPattern\",\n      \"RestElement\",\n    ]),\n  );\n\n  visitorKeysMap = Object.entries(VISITOR_KEYS).reduce((acc, [key, value]) => {\n    if (!flowFlippedAliasKeys.has(value)) {\n      // @ts-expect-error FIXME: value is not assignable to type string[]\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n\n  return visitorKeysMap[nodeType];\n}\n\nconst propertyTypes = {\n  // loops\n  callProperties: { type: \"loop\", values: [\"value\"] },\n  indexers: { type: \"loop\", values: [\"key\", \"value\"] },\n  properties: { type: \"loop\", values: [\"argument\", \"value\"] },\n  types: { type: \"loop\" },\n  params: { type: \"loop\" },\n  // single property\n  argument: { type: \"single\" },\n  elementType: { type: \"single\" },\n  qualification: { type: \"single\" },\n  rest: { type: \"single\" },\n  returnType: { type: \"single\" },\n  // others\n  typeAnnotation: { type: \"typeAnnotation\" },\n  typeParameters: { type: \"typeParameters\" },\n  id: { type: \"id\" },\n};\n\nclass PatternVisitor extends OriginalPatternVisitor {\n  ArrayPattern(node: any) {\n    node.elements.forEach(this.visit, this);\n  }\n\n  ObjectPattern(node: any) {\n    node.properties.forEach(this.visit, this);\n  }\n}\n\nclass Referencer extends OriginalReferencer {\n  #client;\n\n  constructor(options: any, scopeManager: any, client: Client) {\n    super(options, scopeManager);\n    this.#client = client;\n  }\n\n  // inherits.\n  visitPattern(node: any, options: any, callback: any) {\n    if (!node) {\n      return;\n    }\n\n    // Visit type annotations.\n    this._checkIdentifierOrVisit(node.typeAnnotation);\n    if (node.type === \"AssignmentPattern\") {\n      this._checkIdentifierOrVisit(node.left.typeAnnotation);\n    }\n\n    // Overwrite `super.visitPattern(node, options, callback)` in order to not visit `ArrayPattern#typeAnnotation` and `ObjectPattern#typeAnnotation`.\n    if (typeof options === \"function\") {\n      callback = options;\n      options = { processRightHandNodes: false };\n    }\n\n    const visitor = new PatternVisitor(this.options, node, callback);\n    visitor.visit(node);\n\n    // Process the right hand nodes recursively.\n    if (options.processRightHandNodes) {\n      visitor.rightHandNodes.forEach(this.visit, this);\n    }\n  }\n\n  // inherits.\n  visitClass(node: any) {\n    // Decorators.\n    this._visitArray(node.decorators);\n\n    // Flow type parameters.\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // Flow super types.\n    this._visitTypeAnnotation(node.implements);\n    this._visitTypeAnnotation(\n      (process.env.BABEL_8_BREAKING\n        ? // @ts-ignore(Babel 7 vs Babel 8) Renamed\n          node.superTypeArguments\n        : // @ts-ignore(Babel 7 vs Babel 8) Renamed\n          node.superTypeParameters\n      )?.params,\n    );\n\n    // Basic.\n    super.visitClass(node);\n\n    // Close the type parameter scope.\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  // inherits.\n  visitFunction(node: any) {\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // Flow return types.\n    this._checkIdentifierOrVisit(node.returnType);\n\n    // Basic.\n    super.visitFunction(node);\n\n    // Close the type parameter scope.\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  // inherits.\n  visitProperty(node: any) {\n    if (node.value?.type === \"TypeCastExpression\") {\n      this._visitTypeAnnotation(node.value);\n    }\n    this._visitArray(node.decorators);\n    super.visitProperty(node);\n  }\n\n  InterfaceDeclaration(node: any) {\n    this._createScopeVariable(node, node.id);\n\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // TODO: Handle mixins\n    this._visitArray(node.extends);\n    this.visit(node.body);\n\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  TypeAlias(node: any) {\n    this._createScopeVariable(node, node.id);\n\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    this.visit(node.right);\n\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  ClassProperty(node: any) {\n    this._visitClassProperty(node);\n  }\n\n  ClassPrivateProperty(node: any) {\n    this._visitClassProperty(node);\n  }\n\n  AccessorProperty(node: any) {\n    this._visitClassProperty(node);\n  }\n\n  ClassAccessorProperty(node: any) {\n    this._visitClassProperty(node);\n  }\n\n  PropertyDefinition(node: any) {\n    this._visitClassProperty(node);\n  }\n\n  // TODO: Update to visit type annotations when TypeScript/Flow support this syntax.\n  ClassPrivateMethod(node: any) {\n    super.MethodDefinition(node);\n  }\n\n  DeclareModule(node: any) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareFunction(node: any) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareVariable(node: any) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareClass(node: any) {\n    this._visitDeclareX(node);\n  }\n\n  // visit OptionalMemberExpression as a MemberExpression.\n  OptionalMemberExpression(node: any) {\n    super.MemberExpression(node);\n  }\n\n  _visitClassProperty(node: any) {\n    const { computed, key, typeAnnotation, decorators, value } = node;\n\n    this._visitArray(decorators);\n    if (computed) this.visit(key);\n    this._visitTypeAnnotation(typeAnnotation);\n\n    if (value) {\n      if (this.scopeManager.__nestClassFieldInitializerScope) {\n        this.scopeManager.__nestClassFieldInitializerScope(value);\n      } else {\n        // Given that ESLint 7 didn't have a \"class field initializer\" scope,\n        // we create a plain method scope. Semantics are the same.\n        this.scopeManager.__nestScope(\n          new Scope(\n            this.scopeManager,\n            \"function\",\n            this.scopeManager.__currentScope,\n            value,\n            true,\n          ),\n        );\n      }\n      this.visit(value);\n      this.close(value);\n    }\n  }\n\n  _visitDeclareX(node: any) {\n    if (node.id) {\n      this._createScopeVariable(node, node.id);\n    }\n\n    const typeParamScope = this._nestTypeParamScope(node);\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  _createScopeVariable(node: any, name: any) {\n    this.currentScope().variableScope.__define(\n      name,\n      new Definition(\"Variable\", name, node, null, null, null),\n    );\n  }\n\n  _nestTypeParamScope(node: any) {\n    if (!node.typeParameters) {\n      return null;\n    }\n\n    const parentScope = this.scopeManager.__currentScope;\n    const scope = new Scope(\n      this.scopeManager,\n      \"type-parameters\",\n      parentScope,\n      node,\n      false,\n    );\n\n    this.scopeManager.__nestScope(scope);\n    for (let j = 0; j < node.typeParameters.params.length; j++) {\n      const name = node.typeParameters.params[j];\n      scope.__define(name, new Definition(\"TypeParameter\", name, name));\n      if (name.typeAnnotation) {\n        this._checkIdentifierOrVisit(name);\n      }\n    }\n    scope.__define = parentScope.__define.bind(parentScope);\n\n    return scope;\n  }\n\n  _visitTypeAnnotation(node: any) {\n    if (!node) {\n      return;\n    }\n    if (Array.isArray(node)) {\n      node.forEach(this._visitTypeAnnotation, this);\n      return;\n    }\n\n    // get property to check (params, id, etc...)\n    const visitorValues = getVisitorValues(node.type, this.#client);\n    if (!visitorValues) {\n      return;\n    }\n\n    // can have multiple properties\n    for (let i = 0; i < visitorValues.length; i++) {\n      const visitorValue = visitorValues[i];\n      const propertyType = (propertyTypes as Record<string, any>)[visitorValue];\n      const nodeProperty = node[visitorValue];\n      // check if property or type is defined\n      